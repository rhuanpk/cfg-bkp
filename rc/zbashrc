# >>> The Ultimate Home <<<

home=${HOME:-"/home/${USER:-$(whoami)}"}

# >>> Unset Alias'es <<<

aliases_array=(ll lla ggb ggl ggd ggs ggr ggp ggls ggsa ggpa ggra)

for index in ${aliases_array[@]}; do
	if alias ${index} >/dev/null 2>&1; then
		unalias ${index}
	fi
done

# >>> Standard Aliases <<<

alias cb="tr -d '\n' | xclip -selection clipboard"
alias cbfull='xclip -selection clipboard'

alias ggb='git branch -l --color | cat'
alias ggl='git log --all --oneline --patch'
alias ggd='git diff --color | cat'
alias ggs='git status'
alias ggr='git restore ./; git clean -f ./'
alias ggp='git pull origin $(git branch --show-current); git fetch --tags'
alias ggls='git log --all --oneline'
alias ggpa='push_script -g'
alias ggsa='push_script "git status"'
alias ggra='push_script "git restore ./"; push_script "git clean -f"'

alias insp='viewvar ${1}'
alias sz='source ~/.zshrc'
alias sb='source ~/.bashrc'
alias vimz='vim ~/.zshrc'
alias vimb='vim ~/.bashrc'
alias catz='cat ~/.zshrc'
alias catb='cat ~/.bashrc'
alias intrr='echo "${?}"'
alias tmp='[ ! -d /tmp/tmp ] && { mkdir -v /tmp/tmp && cd /tmp/tmp ;} || cd /tmp/tmp'
alias mkfile='touch file-{1..4}.{txt,md,new,tmp}'
alias mkfiled='mkdir -p dir_{1..2}/{a..c}'
alias TOKEN="toplip -d ${home}/Documents/git/cfg-bkp/enkrypted/nekot.txt | tr -d '\n' | xclip -selection clipboard"
alias default_montage='sudo mount -o rw,uid=$(id -u),gid=$(id -g)'
alias rmallz='setopt extendedglob; rm -rfv ./(.|)*'
alias rmallb='shopt -s extglob; rm -rfv ./{.[^.]*,*}'
alias external_ip="curl -fsSL http://ipecho.net/plain | sed 's/$/\n/'"
#alias pgcat='pygmentize -l'
alias hlcat='highlight -O ansi'

alias sudo='sudo -k'

alias lsblkf='lsblk --output=NAME,RO,RM,SIZE,MOUNTPOINTS'
alias lsblkd='lsblk --output=MODEL,STATE,TYPE,PATH,FSTYPE,LABEL,UUID'
alias dff='df --exclude-type=tmpfs --output=source,size,used,pcent,avail,target -h'

# >>> Standard Short Functions <<<

viewvar() { eval echo "\${${1}}"; }
yts() { trans -b en:pt-br "$(rtstr ${1})"; }
ytsbr() { trans -b pt-br:en "$(rtstr ${1})"; }
pick_alias() { alias "${1}" | cut -d '=' -f 2- | sed -E 's/^.{1}|.{1}$//g'; }
ae() { [ -f "${1}" ] && echo 'file exists!' || echo 'file not exists!'; }
diffstr() { if diff <(rtstr "${1}") <(rtstr "${2}"); then echo -e "\e[1;32;40mNo differences ✔\e[m"; fi; }
#readmd() { pandoc -f markdown "${1}" | lynx -stdin; }
rlbc() { file="${1}"; [ -z $file ] && echo 'needs a file to execute!' || sed -Ei 's/[[:blank:]]+$//g' "${file}"; }

ll() { route=$([ ${#} -eq 0 ] && pwd || echo ${1}); ls -lhF --time-style=+%% --color ${route}; echo "count $(ls -1 ${route} | wc -l)"; }
lla() { route=$([ ${#} -eq 0 ] && pwd || echo ${1}); ls -lhAF --time-style=+%% --color ${route}; echo "count $(ls -A1 ${route} | wc -l)"; }

# =============================================================================================

# ToDo List (SlackJeff)

TODO="${home}/Documents/anotacoes/.todo_list.txt"

rand() { RAND=0; while [ ${#RAND} -lt 4 ]; do RAND=$((${RANDOM}%10000)); done; }
tla() { rand; [ ${#} -eq 0 ] && cat "${TODO}" || echo "($(hostname)) ${RAND} » ${*}" >> ${TODO}; }
tlr() { sed -i "/^($(hostname)) ${1}/d" ${TODO}; clear; tla; }

# =============================================================================================

# >>> Standard Long Functions !

mychecking() {
	clear
	ggsa
	tree -FL 2 ~
	find ~/ -iname '*confli*' | sed -E '/(\.icons|\.themes|\.private|pCloudDrive|Code\/CachedData|share\/Trash|\.go\/pkg)/d'
}

difftext() {
	local phrase
	if phrase=$(wdiff <(rtstr "${1}") <(rtstr "${2}")); then
		echo -e "\e[1;32;40mNo differences ✔\e[m"
	else
		colordiff <<< $phrase | sed -E 's/\[-|-\]|\{\+|\+\}//g'
	fi
}

utilitarios() {
	cd /tmp/
	file=$(find ~/ -name 'comandos_uteis.md' | grep -F comandos-linux | grep -viE '(pclouddrive|others)')
	hlcat $file | less
}

outfind() {
	tmp_find_path=/tmp/output_find.tmp
	f_time=1
	find / \( -path /proc -prune -o -path /sys -prune \) -o -iname "*${1}*" >${tmp_find_path} 2>&- &
	while (ps ${!} >/dev/null); do sleep 1; echo -ne "\rtime: ${f_time}s"; let ++f_time; done; echo
	less ${tmp_find_path}
}

set_polybar_all() {
	{
		echo -e $'#!/bin/bash\nMONITOR=MERGE-1 polybar my-bar' | \
		tee /tmp/polybar.sh
	} && \
	chmod -v +x /tmp/polybar.sh && \
	killall polybar && \
	{
		echo 'success on killall!'
		sleep 3
		nohup /tmp/polybar.sh &
	} || \
	echo 'failed on killall!'
}

print_regex_classes() {
	cat <<- EOF
		------------------------------------------------------------------------------------
		Classes
		[[:alnum:]] ------ Alfabéticos e númericos [a-z A-Z 0-9]
		[[:alpha:]] ------ Alfabéticos [a-z A-Z]
		[[:blank:]] ------ Caractere em branco, espaço ou tab [ \t]
		[[:cntrl:]] ------ Caracteres de controle [\x00-\x1F\x7F]
		[[:digit:]] ------ Números [0-9]
		[[:graph:]] ------ Qualquer caractere visível(ou seja, exceto em branco) [\x20-\x7E]
		[[:lower:]] ------ Letras minúsculas [a-z]
		[[:upper:]] ------ Letras maiúsculas [A-Z]
		[[:print:]] ------ Caracteres visíveis (ou seja, exceto os de controle) [\x20-\x7E]
		[[:punct:]] ------ Pontuação [-!"#$%&'()*+,./:;?@[\\\]_{|}~].
		[[:space:]] ------ Espaço em branco [ \t\r\n\v\f]
		[[:xdigit:]] ----- Número hexadecimais [0-9 a-f A-F]
		------------------------------------------------------------------------------------
		Abreviações
		[[:digit:]] ------ \d
		[[:alnum:]] ------ \w
		[[:space:]] ------ \s
		------------------------------------------------------------------------------------
	EOF
}

print_array_expasion() {
	cat <<- EOF
		----------------------------------------------------------------------------------
		\${var[@]} ----------- Imprime todos os elementos do array em strings protegidas.
		\${var[*]} ----------- Imprime todos os elementos do array em uma única expressão.
		\${var[P]} ----------- Imprime o elemento na posição ‘P’.
		\${#var[@]} ---------- Imprime o total de elementos do array.
		\${!var[@]} ---------- Imprime os índices do array.
		\${var[@]:N} --------- Imprime todos os elementos a partir da posição ‘N’.
		\${var[@]:N:M} ------- Imprime ‘M’ elementos a partir da posição ‘N’.
		\${var[@]: -N} ------- Imprime os últimos ‘N’ elementos.
		\${var[@]: -N:M} ----- Imprime ‘M’ elementos a partir da última ‘N’ posição.
		----------------------------------------------------------------------------------
	EOF
}

print_extglob_bash() {
	cat <<- EOF
		-----------------------------------------------------------------------
		?(padrão) .....: Corresponde a uma ocorrência do padrão
		*(padrão) .....: Corresponde a qualquer número de ocorrências do padrão
		+(padrão) .....: Corresponde a pelo menos uma ocorrência do padrão
		@(padrão) .....: Corresponde exatamente a uma ocorrência do padrão
		!(padrão) .....: Corresponde a tudo, exceto o padrão
		-----------------------------------------------------------------------
	EOF
}

print_extglob_zsh() {
	cat <<- EOF
		-------------------------------------------------
		^foobar ........: Nega o padrão
		^(foo|bar) .....: Nega os padrões
		foo~bar ........: Aceita "foo" e nega "bar"
		(foo)# .........: Zero ou mais ocorrências de foo
		(foo)## ........: Uma ou mais ocorrências de foo
		-------------------------------------------------
	EOF
}

# =============================================================================================

